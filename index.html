<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Art Slideshow">
<link rel="apple-touch-icon" href="apple-touch-icon.png">

<title>Art Nightstand Slideshow</title>
<style>
  :root{
    --bg:#0b0b0f; --fg:#e9e9ef; --muted:#9aa0a6; --accent:#6ee7ff; --surface:#121218; --btn:#1e1e27;
    --good:#2bd576; --bad:#ff6b6b; --shadow:0 10px 30px rgba(0,0,0,.35); --radius:18px; --step-fade:450ms;
    --accent-text: color-mix(in srgb, var(--accent) 70%, white 30%);
    --title-fg: color-mix(in srgb, var(--fg) 85%, var(--muted) 15%);
  }
  *{box-sizing:border-box}
  html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); }
  body{
    font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    -webkit-tap-highlight-color: transparent;
    user-select: none; -webkit-user-select: none; -webkit-touch-callout: none;
    touch-action: manipulation;
    overflow:hidden;
  }
  /* Allow typing in inputs (especially iOS PWA) */
  input, textarea, select {
    user-select: text; -webkit-user-select: text;
    -webkit-touch-callout: default;
    touch-action: auto;
  }
  /* Ensure all controls inside the dialog behave like normal form controls */
  .modal * {
    user-select: text !important; -webkit-user-select: text !important;
    touch-action: auto !important;
  }

  /* Fullscreen stage (letterboxing allowed) */
  .stage{
    position:fixed; inset:0;
    width:100vw; height:100vh; height:100svh;
    display:grid; place-items:center;
    z-index:0;
  }

  /* 16:9 frame always fully in view — never clipped */
  .frame{
    position:relative;
    width: min(100vw, calc(100svh * (16/9)));
    height:min(100svh, calc(100vw * (9/16)));
    width: min(100vw, calc(100vh * (16/9)));
    height:min(100vh, calc(100vw * (9/16)));
    aspect-ratio:16/9;
    border-radius:var(--radius);
    overflow:hidden;
    box-shadow:var(--shadow);
    display:grid; grid-template-columns:34% 66%;
  }

  .frame-backdrop {
    position:absolute; inset:0; z-index:0;
    background-position:center; background-size:cover;
    filter: blur(40px) brightness(.35) saturate(.9);
    transform: scale(1.12);
    border-radius:inherit;
  }

  .side, .art, .hits, .footer { position:relative; z-index:1; }

  .side{
    display:flex; flex-direction:column; justify-content:flex-start;
    padding:1.2rem; gap:1rem;
    background:linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,0) 42%);
    grid-column:1; pointer-events:none;
  }

  .clockWrap{ display:flex; flex-direction:column; align-items:flex-start; gap:.2rem; }
  .clock{
    font-variant-numeric:tabular-nums; font-weight:800; line-height:1; letter-spacing:.5px; color:var(--accent-text);
    text-shadow:0 0 24px color-mix(in srgb, var(--accent) 40%, transparent);
  }
  .clock .ampm{ font-weight:600; color: color-mix(in srgb, var(--accent) 80%, white 12%); opacity:.95; margin-left:.25em; }

  .meta{ display:flex; flex-direction:column; gap:.35rem; max-width:95%; }
  .kicker{ color:var(--accent-text); text-transform:uppercase; letter-spacing:.18em; font-weight:700; font-size:1rem; opacity:0; transform:translateY(8px); }
  .title{ color:var(--title-fg); font-size:clamp(1.2rem, 3.6vw, 2.2rem); font-weight:800; letter-spacing:.2px; line-height:1.1; opacity:0; transform:translateY(8px); }
  .sub{ color:var(--muted); font-size:clamp(.95rem, 2.2vw, 1.05rem); opacity:0; transform:translateY(8px); }
  .reveal{ animation: fadeUp var(--step-fade) ease forwards; }
  .reveal:nth-child(1){ animation-delay:0ms } .reveal:nth-child(2){ animation-delay:80ms } .reveal:nth-child(3){ animation-delay:120ms }
  @keyframes fadeUp { to {opacity:1; transform: translateY(0)} }

  /* === FULL IMAGE, NO CROP === */
  .art{
    grid-column:2;
    position:relative;
    width:100%; height:100%;
    display:flex; align-items:center; justify-content:center; /* center the intrinsic box */
    min-width:0; min-height:0; /* prevent grid overflow quirks */
  }
  .art img{
    display:block;
    width:auto; height:auto;               /* keep intrinsic aspect ratio */
    max-width:100%; max-height:100%;       /* scale down to fit the cell */
    object-fit:contain; object-position:center center; /* belt + suspenders */
    filter: drop-shadow(0 20px 40px rgba(0,0,0,.35));
    pointer-events:none;                   /* let overlay receive taps */
  }

  .tint{ position:absolute; inset:-12%; background:radial-gradient(60% 50% at 50% 65%, color-mix(in srgb, var(--accent) 22%, transparent), transparent 70%); filter: blur(60px); opacity:.6; pointer-events:none }

  /* In-frame hit zones overlay (for clicks) */
  .hits{ position:absolute; inset:0; display:grid; grid-template-columns:1fr 1fr; z-index:3; }
  .hit{ cursor:pointer; }

  /* Footer UI */
  .footer{
    position:absolute; left:0; right:0; bottom:0;
    display:flex; justify-content:space-between; align-items:center; gap:.6rem;
    padding:.8rem 1rem; z-index:5; pointer-events:none;
  }
  .leftGroup, .chip{ pointer-events:auto; }
  .btn{
    background:var(--btn); color:var(--fg); border:1px solid rgba(255,255,255,.08);
    padding:.8rem 1.1rem; border-radius:14px; cursor:pointer;
    transition: transform .06s ease, background .2s ease, border-color .2s ease, box-shadow .2s ease;
    overflow:hidden;
  }
  .btn:hover{ transform: translateY(-1px); }
  .btn.good{ border-color: color-mix(in srgb, var(--good) 55%, transparent); box-shadow: 0 0 0 1px color-mix(in srgb, var(--good) 30%, transparent) inset; }
  .btn.bad{ border-color: color-mix(in srgb, var(--bad) 55%, transparent); box-shadow: 0 0 0 1px color-mix(in srgb, var(--bad) 30%, transparent) inset; }
  .btn.selected{ box-shadow: 0 0 0 2px currentColor inset; outline:none; filter:none; }
  .chip{ position:absolute; top:.6rem; right:.6rem; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08); border-radius:999px; padding:.25rem .6rem; color:var(--muted); font-size:.9rem; z-index:6; }

  dialog{ border:none; border-radius:16px; background:var(--surface); color:var(--fg); width:min(900px, 95vw); box-shadow: var(--shadow); }
  dialog::backdrop{ background:rgba(0,0,0,.6); backdrop-filter: blur(3px); }
  .modal{ padding:1rem; display:grid; gap:1rem; }
  .grid2{ display:grid; grid-template-columns:1fr 1fr; gap:.8rem; }
  .grid3{ display:grid; grid-template-columns:repeat(4, 1fr); gap:.8rem; }
  .field label{ display:block; font-size:.9rem; color:var(--muted); margin-bottom:.25rem; }
  .field input, .field select{ width:100%; background:#0f0f15; border:1px solid rgba(255,255,255,.1); color:var(--fg); padding:.55rem .6rem; border-radius:10px; }
  .list{ max-height:45vh; overflow:auto; border:1px solid rgba(255,255,255,.08); border-radius:12px; }
  .row{ display:grid; grid-template-columns:auto 1fr auto; gap:.6rem; align-items:center; padding:.5rem .6rem; border-bottom:1px solid rgba(255,255,255,.06); }
  .row:last-child{ border-bottom:none; }
  .pill{ padding:.25rem .6rem; border-radius:999px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); color:var(--muted); }
  .actions{ display:flex; gap:.6rem; justify-content:flex-end; }

  .lightbox{ position:fixed; inset:0; background:rgba(0,0,0,.8); backdrop-filter: blur(3px); display:none; align-items:center; justify-content:center; z-index:9999; cursor:pointer; }
  .lightbox.show{ display:flex; }
  .lightbox img{ max-width:95vw; max-height:95vh; object-fit:contain; border-radius:12px; box-shadow: var(--shadow); cursor:default; user-select:auto; -webkit-user-select:auto; -webkit-touch-callout:default; }

  /* top-left pill "Remove" control with visual toggle */
  .lightboxTools{
    position: absolute;
    top: 2vw; left: 2vw;
    transform: none;
    background: rgba(0,0,0,.55);
    border: 1px solid rgba(255,255,255,.18);
    border-radius: 999px;
    padding: .2rem;
    display: flex; align-items: center; gap: .2rem;
    pointer-events: auto;
    backdrop-filter: blur(4px);
    box-shadow: 0 6px 16px rgba(0,0,0,.35);
  }
  .remove-toggle{
    display: inline-flex; align-items: center;
  }
  .remove-toggle input[type="checkbox"]{
    display: none;
  }
  .remove-toggle .toggle-pill{
    padding: .38rem .7rem;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,.18);
    background: rgba(255,255,255,.06);
    color: var(--fg);
    font-size: .95rem; font-weight: 600; letter-spacing: .01em;
    transition: background .18s ease, color .18s ease, border-color .18s ease, box-shadow .18s ease;
    cursor: pointer; user-select: none;
  }
  .remove-toggle input:checked + .toggle-pill{
    background: var(--accent);
    color: #0b1020;
    border-color: color-mix(in srgb, var(--accent) 45%, #000 55%);
    box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent) 40%, transparent) inset;
  }
  .remove-toggle input:not(:checked) + .toggle-pill{
    box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset;
  }

  @media (orientation: landscape){ .clock{ font-size: clamp(2.6rem, 7vw, 5.2rem); } }
  @media (orientation: portrait){ .clock{ font-size: clamp(2.2rem, 10vw, 4.2rem); } }
</style>
</head>
<body>
  <main class="stage" id="stage">
    <section class="frame" id="frame">
      <div class="frame-backdrop" id="frameBackdrop"></div>
      <aside class="side">
        <div class="clockWrap">
          <div class="clock" id="clock">--:--<span class="ampm" id="ampm"></span></div>
        </div>
        <div class="meta">
          <div id="artist" class="kicker" aria-hidden="true"></div>
          <div id="title" class="title" aria-hidden="true"></div>
          <div id="details" class="sub" aria-hidden="true"></div>
        </div>
      </aside>

      <div class="art" id="artArea">
        <div class="tint" id="tint"></div>
        <img id="artImg" alt="Artwork" />
      </div>

      <div class="hits" id="hits">
        <div class="hit" id="hitLeft" aria-label="Back"></div>
        <div class="hit" id="hitRight" aria-label="Forward"></div>
      </div>

      <div class="footer">
        <div class="leftGroup">
          <button id="btnBad" class="btn bad">Not yet</button>
          <button id="btnGood" class="btn good">Got it</button>
          <button id="btnSettings" class="btn" title="Settings">⚙️</button>
        </div>
        <span class="chip" id="chip">—</span>
      </div>
    </section>
  </main>

  <dialog id="settings" tabindex="-1">
    <form method="dialog" class="modal" id="settingsForm">
      <h3 style="margin:.2rem 0 .2rem">Settings</h3>
      <div class="grid2">
        <div class="field"><label>New Cards Per Day</label><input name="newCount" type="number" inputmode="numeric" pattern="[0-9]*" min="0" value="5"></div>
        <div class="field"><label>Max Reviews Per Day</label><input name="maxReviews" type="number" inputmode="numeric" pattern="[0-9]*" min="0" value="20" placeholder="999 for all due"></div>
      </div>
      <div class="field"><label>Base image path</label><input name="imageBase" type="text" placeholder="./art/" value="./art/"></div>
      <div class="grid3">
        <div class="field"><label>Image-only (s)</label><input name="tImage" type="number" inputmode="numeric" pattern="[0-9]*" min="1" value="4"></div>
        <div class="field"><label>Artist (s)</label><input name="tArtist" type="number" inputmode="numeric" pattern="[0-9]*" min="1" value="3"></div>
        <div class="field"><label>Title (s)</label><input name="tTitle" type="number" inputmode="numeric" pattern="[0-9]*" min="1" value="3"></div>
        <div class="field"><label>Details (s)</label><input name="tDetails" type="number" inputmode="numeric" pattern="[0-9]*" min="1" value="4"></div>
      </div>
      <div class="field"><label>Auto accent</label><select name="autoAccent"><option value="on">On</option><option value="off">Off</option></select></div>

      <div class="row" style="justify-content:space-between"><strong>Today's repertoire</strong><span class="pill" id="selCount">0/0</span></div>
      <div class="field"><label>Search</label><input type="text" id="search" placeholder="Filter by artist or title"></div>
      <div class="list" id="deckList"></div>

      <!-- Removed-from-pool manager -->
      <div class="row" style="justify-content:space-between; margin-top: 1rem;"><strong>Removed from study pool</strong><span class="pill" id="removedCount">0</span></div>
      <div class="list" id="removedList"></div>

      <div class="row" style="justify-content:space-between; margin-top: 1rem;"><strong>Manage Data</strong></div>
      <div class="actions">
        <button type="button" id="btnExport" class="btn">Download Progress</button>
        <button type="button" id="btnImport" class="btn">Upload Progress</button>
      </div>
      <input type="file" id="importFile" accept=".json" style="display:none;">
      <div class="actions" style="margin-top: 1rem;">
        <button class="btn" value="cancel">Close</button>
        <button class="btn good" value="save">Save</button>
      </div>
    </form>
  </dialog>

  <!-- Lightbox with top-left "Remove" pill that visibly toggles -->
  <div class="lightbox" id="mainLightbox">
    <div class="lightboxTools">
      <label class="remove-toggle">
        <input type="checkbox" id="removeToggle">
        <span class="toggle-pill">Remove</span>
      </label>
    </div>
    <img id="mainLightboxImg" alt="Full artwork view">
  </div>

<script>
const CONFIG_KEY   = 'artSRS_config_v7';
const STATE_KEY    = 'artSRS_state_v6';
const TODAY_KEY    = 'artSRS_today_v3';
const EXCLUDED_KEY = 'artSRS_excluded_v1';

const DEFAULTS = {
  newCount: 5, maxReviews: 20, tImage:4, tArtist:3, tTitle:3, tDetails:4,
  imageBase:'./art/', autoAccent:'on', easeDefault:2.5
};

const el = {
  stage: document.getElementById('stage'),
  frame: document.getElementById('frame'),
  frameBackdrop: document.getElementById('frameBackdrop'),
  img: document.getElementById('artImg'),
  clock: document.getElementById('clock'), ampm: document.getElementById('ampm'),
  artist: document.getElementById('artist'), title: document.getElementById('title'), details: document.getElementById('details'),
  hits: document.getElementById('hits'),
  btnGood: document.getElementById('btnGood'), btnBad: document.getElementById('btnBad'), btnSettings: document.getElementById('btnSettings'),
  chip: document.getElementById('chip'),
  settings: document.getElementById('settings'), settingsForm: document.getElementById('settingsForm'),
  deckList: document.getElementById('deckList'), selCount: document.getElementById('selCount'), search: document.getElementById('search'),
  removedList: document.getElementById('removedList'), removedCount: document.getElementById('removedCount'),
  artArea: document.getElementById('artArea'),
  mainLightbox: document.getElementById('mainLightbox'),
  mainLightboxImg: document.getElementById('mainLightboxImg'),
  removeToggle: document.getElementById('removeToggle'),
  btnExport: document.getElementById('btnExport'), btnImport: document.getElementById('btnImport'), importFile: document.getElementById('importFile')
};

let cfg = loadConfig();
let excluded = loadExcluded();
let deck = [];
let progress = loadState();
let playlist = [];
let todaySel = loadToday();
let session = { index:0, phase:0, timer: {}, today: dayISO(new Date()) };
let isLongPressOpeningLightbox = false;

function loadConfig(){ const raw=localStorage.getItem(CONFIG_KEY); return raw?{...DEFAULTS, ...JSON.parse(raw)}:{...DEFAULTS}; }
function saveConfig(){ localStorage.setItem(CONFIG_KEY, JSON.stringify(cfg)); }
function loadState(){ const raw=localStorage.getItem(STATE_KEY); return raw?JSON.parse(raw):{}; }
function saveState(){ localStorage.setItem(STATE_KEY, JSON.stringify(progress)); }
function loadToday(){ const raw=localStorage.getItem(TODAY_KEY); return raw?JSON.parse(raw):{date: dayISO(new Date()), ids: []}; }
function saveToday(){ localStorage.setItem(TODAY_KEY, JSON.stringify(todaySel)); }
function loadExcluded(){ const raw=localStorage.getItem(EXCLUDED_KEY); try{ return raw? new Set(JSON.parse(raw)) : new Set(); }catch{ return new Set(); } }
function saveExcluded(){ localStorage.setItem(EXCLUDED_KEY, JSON.stringify([...excluded])); }

function dayISO(d){ const z=new Date(d.getFullYear(), d.getMonth(), d.getDate()); return z.toISOString().slice(0,10); }
function cleanText(val){ if(val==null) return ''; const tmp=document.createElement('div'); tmp.innerHTML=String(val); return (tmp.textContent||tmp.innerText||'').trim(); }

function startTimer(callback, duration) {
  clearTimeout(session.timer.id);
  session.timer = { id: setTimeout(callback, duration), startTime: Date.now(), duration, callback };
}
function pauseTimer() {
  if (!session.timer.id) return;
  clearTimeout(session.timer.id);
  const elapsed = Date.now() - session.timer.startTime;
  session.timer.remaining = session.timer.duration - elapsed;
}
function resumeTimer() {
  if (!session.timer.id || session.timer.remaining == null) return;
  if (session.timer.remaining > 0) { startTimer(session.timer.callback, session.timer.remaining); }
  else { session.timer.callback(); }
  session.timer.remaining = null;
}

function ensureProgress(card){ if(!progress[card.id]) { progress[card.id] = { ease: cfg.easeDefault, intervalDays:0, dueISO: session.today, reps:0, lapses:0, state:'new', learningStep:0, lastGrade:null }; } return progress[card.id]; }
function grade(card, kind){
  const p=ensureProgress(card);
  if(kind==='good'){
    if(p.state==='new'){ p.state='learning'; p.learningStep=1; p.intervalDays=1; p.dueISO=dayISO(new Date(Date.now()+86400000)); }
    else if(p.state==='learning'){ if(p.learningStep===1){ p.learningStep=2; p.intervalDays=3; p.dueISO=dayISO(new Date(Date.now()+3*86400000)); } else { p.state='review'; p.learningStep=0; p.intervalDays=Math.max(5, p.intervalDays||5); p.dueISO=dayISO(new Date(Date.now()+p.intervalDays*86400000)); } }
    else { const next=Math.round(Math.max(1, p.intervalDays*p.ease)); p.intervalDays=next; p.dueISO=dayISO(new Date(Date.now()+next*86400000)); } p.reps++;
  } else {
    p.lapses++; p.state='learning'; p.learningStep=1; p.intervalDays=1; p.dueISO=dayISO(new Date(Date.now()+86400000));
  }
  p.lastGrade = kind; saveState(); showGradeFeedback(kind);
}

function autoAccentFromImage(img){
  try{
    const c=document.createElement('canvas'); const ctx=c.getContext('2d',{willReadFrequently:true});
    const w=c.width=80, h=c.height=80; ctx.drawImage(img,0,0,w,h);
    const data=ctx.getImageData(0,0,w,h).data; let r=0,g=0,b=0,cnt=0;
    for(let i=0;i<data.length;i+=4){ const a=data[i+3]; if(a<30) continue; r+=data[i]; g+=data[i+1]; b+=data[i+2]; cnt++; }
    if(cnt){ r=Math.round(r/cnt); g=Math.round(g/cnt); b=Math.round(b/cnt); document.documentElement.style.setProperty('--accent',`rgb(${r},${g},${b})`); }
  }catch(e){}
  el.frameBackdrop.style.backgroundImage = `url('${img.currentSrc || img.src}')`;
}

function fmtTime(d){ let h=d.getHours(); const m=d.getMinutes().toString().padStart(2,'0'); const ampm=h>=12?'PM':'AM'; h=h%12||12; return {h,m,ampm}; }
function startClock(){ const tick=()=>{const d=new Date();const{h,m,ampm}=fmtTime(d);el.clock.textContent=`${h}:${m}`;el.ampm.textContent=ampm;}; tick(); setInterval(tick,15000); }

// --- Keep screen awake (Wake Lock API) ---
let wakeLock = null;

async function requestWakeLock() {
  try {
    wakeLock = await navigator.wakeLock.request('screen');
    wakeLock.addEventListener('release', () => {
      console.log('[wakeLock] released by the system');
      wakeLock = null;
    });
    console.log('[wakeLock] acquired');
  } catch (err) {
    console.warn('[wakeLock] failed:', err.name, err.message);
  }
}

// Ask for wake lock on the first user gesture (required on iOS/Safari)
function setupWakeLockOnce() {
  const handler = () => {
    if ('wakeLock' in navigator && !wakeLock) requestWakeLock();
    window.removeEventListener('pointerdown', handler, { capture: true });
  };
  window.addEventListener('pointerdown', handler, { capture: true, once: true });
}

// Re-acquire if the app becomes visible again
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible' && 'wakeLock' in navigator && !wakeLock) {
    requestWakeLock();
  }
});

// Be polite on leave
window.addEventListener('pagehide', () => {
  try { wakeLock?.release(); } catch {}
});


/* Exclude removed cards from selection */
function ensureToday(){
  const today=dayISO(new Date());
  if(todaySel.date!==today) todaySel={date:today,ids:[]};
  if(!todaySel.ids.length){
    const dueCards=[], freshCards=[];
    for(const c of deck){
      if(excluded.has(c.id)) continue;
      const p=ensureProgress(c);
      if(p.state==='new'){ freshCards.push(c.id); }
      else if(p.dueISO<=today){ dueCards.push(c.id); }
    }
    const shuffledDue = dueCards.sort(() => 0.5 - Math.random());
    const shuffledFresh = freshCards.sort(() => 0.5 - Math.random());
    const reviews = shuffledDue.slice(0, cfg.maxReviews);
    const news = shuffledFresh.slice(0, cfg.newCount);
    todaySel.ids = [...reviews, ...news];
    saveToday();
  }
}

function buildPlaylist(){
  ensureToday();
  const map=new Map(deck.map(c=>[c.id,c]));
  playlist=todaySel.ids.map(id=>map.get(id))
    .filter(Boolean)
    .filter(c=>!excluded.has(c.id));
  session.index=0;
  updateChip();
}
function hideMeta(){ [el.artist,el.title,el.details].forEach(n=>{n.classList.remove('reveal');n.style.opacity=0;n.style.transform='translateY(8px)';}); }

async function showCurrent(auto=true){
  const card=playlist[session.index]; if(!card){el.title.textContent='No artwork scheduled for today.';return;}
  resetGradeFeedback(); const p=progress[card.id]; if(p&&p.lastGrade) showGradeFeedback(p.lastGrade);
  hideMeta();
  await loadImageFor(card);
  /* force full, uncropped view */
  el.img.style.width='auto'; el.img.style.height='auto'; el.img.style.maxWidth='100%'; el.img.style.maxHeight='100%';
  el.img.style.objectFit='contain'; el.img.style.objectPosition='center center';
  if(cfg.autoAccent==='on') autoAccentFromImage(el.img);
  if(auto) runReveal(); updateChip();
}

function loadImageFor(card){
  return new Promise((resolve)=>{
    const src = card.image.startsWith('http') ? card.image : (cfg.imageBase||'./') + card.image;
    el.img.onload=()=>resolve(); el.img.onerror=()=>resolve(); el.img.src=src;
  });
}

function revealStep(){
  const card=playlist[session.index]; if(!card) return;
  const map=[null,el.artist,el.title,el.details]; const node=map[session.phase]; if(!node) return;
  const contentMap={artist:card.artist,title:card.title,details:[card.date,card.style].filter(Boolean).join(' • ')};
  node.textContent=cleanText(contentMap[node.id]); node.classList.add('reveal'); node.removeAttribute('aria-hidden');
}

function runRevealFromCurrentPhase(){
  const plan=[cfg.tImage,cfg.tArtist,cfg.tTitle,cfg.tDetails].map(Number);
  function scheduleNext(){
    if(session.phase>0) revealStep();
    if(session.phase<3){ startTimer(()=>{ session.phase++; scheduleNext(); }, plan[session.phase]*1000); }
    else { startTimer(()=>{ nextCard(); }, plan[3]*1000); }
  }
  scheduleNext();
}
function runReveal(){ session.phase=0; runRevealFromCurrentPhase(); }
function revealNextStepOrCard(){ if(session.phase<3){ clearTimeout(session.timer.id); session.phase++; runRevealFromCurrentPhase(); } else { nextCard(); } }
function nextCard(){ if(!playlist.length) return; session.index=(session.index+1)%playlist.length; showCurrent(true); }

function hideStepVisual(phaseToHide){ const map=[null,el.artist,el.title,el.details]; const node=map[phaseToHide]; if(node){ node.classList.remove('reveal'); node.setAttribute('aria-hidden','true'); } }
function showAllMeta(){
  const card=playlist[session.index]; if(!card) return;
  el.artist.textContent=cleanText(card.artist);
  el.title.textContent=cleanText(card.title);
  el.details.textContent=cleanText([card.date,card.style].filter(Boolean).join(' • '));
  [el.artist,el.title,el.details].forEach(n=>{n.classList.add('reveal'); n.removeAttribute('aria-hidden');});
}
async function stepBackward(){
  clearTimeout(session.timer.id);
  const plan=[cfg.tImage,cfg.tArtist,cfg.tTitle,cfg.tDetails].map(Number);
  if(session.phase>0){
    hideStepVisual(session.phase); session.phase--;
    startTimer(runRevealFromCurrentPhase, plan[session.phase]*1000);
  } else {
    session.index=(session.index-1+playlist.length)%playlist.length;
    await showCurrent(false);
    session.phase=3; showAllMeta();
    startTimer(()=>{ nextCard(); }, plan[3]*1000);
  }
}

function showGradeFeedback(kind){
  if(kind==='good'){ el.btnGood.classList.add('selected'); el.btnBad.classList.remove('selected'); }
  else { el.btnBad.classList.add('selected'); el.btnGood.classList.remove('selected'); }
}
function resetGradeFeedback(){ el.btnGood.classList.remove('selected'); el.btnBad.classList.remove('selected'); }
function updateChip(){ const n=playlist.length||0; const i=Math.min(session.index+1,Math.max(n,1)); el.chip.textContent=`Today ${i}/${n}`; }

function openSettings(){
  const f=el.settingsForm;
  f.newCount.value = cfg.newCount; f.maxReviews.value = cfg.maxReviews;
  f.imageBase.value=cfg.imageBase; f.tImage.value=cfg.tImage; f.tArtist.value=cfg.tArtist; f.tTitle.value=cfg.tTitle; f.tDetails.value=cfg.tDetails; f.autoAccent.value=cfg.autoAccent;
  buildDeckListFresh();
  buildRemovedList();
  el.settings.showModal();
}

let tempSel=new Set();
function buildDeckListFresh(){
  const term=(el.search.value||'').toLowerCase(); tempSel=new Set(todaySel.ids); el.deckList.innerHTML=''; let selectedCount=tempSel.size;
  const updateSelCount=()=>{el.selCount.textContent=`${selectedCount}/${cfg.newCount + cfg.maxReviews}`;};
  for(const c of deck){
    const artist=cleanText(c.artist),title=cleanText(c.title);
    if(term&&!(artist.toLowerCase().includes(term)||title.toLowerCase().includes(term))) continue;
    const row=document.createElement('div');row.className='row';row.dataset.id=c.id;
    const cb=document.createElement('input');cb.type='checkbox';cb.checked=tempSel.has(c.id);
    const label=document.createElement('div');label.innerHTML=`<strong>${artist||'Unknown'}</strong><br><small>${title||''}</small>`;
    const preview=document.createElement('button');preview.className='btn';preview.textContent='Image';
    cb.addEventListener('change',()=>{ if(cb.checked){tempSel.add(c.id);}else{tempSel.delete(c.id);} selectedCount=tempSel.size; updateSelCount(); });
    preview.addEventListener('click',(e)=>{e.preventDefault(); const src=c.image.startsWith('http')?c.image:(cfg.imageBase||'./')+c.image; el.mainLightboxImg.src=src; el.mainLightbox.classList.add('show'); el.removeToggle.checked=false; });
    row.appendChild(cb);row.appendChild(label);row.appendChild(preview); el.deckList.appendChild(row);
  }
  updateSelCount();
}

/* Removed list in Settings */
function buildRemovedList(){
  el.removedList.innerHTML='';
  const items=[...excluded].map(id=>deck.find(c=>c.id===id)).filter(Boolean);
  el.removedCount.textContent = items.length;
  for(const c of items){
    const row=document.createElement('div'); row.className='row';
    const label=document.createElement('div'); label.innerHTML=`<strong>${cleanText(c.artist)||'Unknown'}</strong><br><small>${cleanText(c.title)||''}</small>`;
    const preview=document.createElement('button'); preview.className='btn'; preview.textContent='Image';
    preview.addEventListener('click',(e)=>{e.preventDefault(); const src=c.image.startsWith('http')?c.image:(cfg.imageBase||'./')+c.image; el.mainLightboxImg.src=src; el.mainLightbox.classList.add('show'); el.removeToggle.checked=false; });
    const restore=document.createElement('button'); restore.className='btn good'; restore.textContent='Restore';
    restore.addEventListener('click',()=>{ excluded.delete(c.id); saveExcluded(); buildRemovedList(); });
    row.appendChild(label); row.appendChild(preview); row.appendChild(restore);
    el.removedList.appendChild(row);
  }
}

function exportData(){
  const dataToExport={config:loadConfig(),state:loadState()};
  const jsonString=JSON.stringify(dataToExport,null,2);
  const blob=new Blob([jsonString],{type:'application/json'}); const url=URL.createObjectURL(blob);
  const a=document.createElement('a');a.href=url; a.download=`art_slideshow_progress_${new Date().toISOString().slice(0,10)}.json`;
  document.body.appendChild(a);a.click();document.body.removeChild(a);URL.revokeObjectURL(url);
}
function importData(){ el.importFile.click(); }
el.importFile.addEventListener('change',(event)=>{
  const file=event.target.files[0]; if(!file) return;
  const reader=new FileReader();
  reader.onload=(e)=>{
    try{
      const data=JSON.parse(e.target.result);
      if(data&&data.config&&data.state){
        localStorage.setItem(CONFIG_KEY,JSON.stringify(data.config));
        localStorage.setItem(STATE_KEY,JSON.stringify(data.state));
        localStorage.removeItem(TODAY_KEY);
        alert('Progress imported successfully! The page will now reload.');
        location.reload();
      }else{ alert('Invalid import file.'); }
    }catch(error){ alert('Error parsing file: '+error.message); }
    event.target.value='';
  };
  reader.readAsText(file);
});

/* NAV: clicks + touch taps */
let lastTouchNavAt = 0;
function onHitClick(e){
  if (el.settings.open || el.mainLightbox.classList.contains('show')) return; // don't navigate while modal open
  if (Date.now() - lastTouchNavAt < 280) return;
  const rect = e.currentTarget.getBoundingClientRect();
  const x = e.clientX - rect.left;
  if (x < rect.width/2){ stepBackward(); } else { revealNextStepOrCard(); }
}

/* Long-press & tap */
let lpTimer=null, touchStartX=0, touchStartY=0, touchStartTime=0, lastTouchX=0, lastTouchY=0;
const LONG_PRESS_MS=1000, MOVE_TOL=12;

function onTouchStart(e){
  if (el.settings.open || el.mainLightbox.classList.contains('show')) return; // don't hijack touches over modals
  const t=e.touches[0];
  touchStartX = lastTouchX = t.clientX;
  touchStartY = lastTouchY = t.clientY;
  touchStartTime = Date.now();

  const artRect = el.artArea.getBoundingClientRect();
  if (t.clientX>=artRect.left && t.clientX<=artRect.right && t.clientY>=artRect.top && t.clientY<=artRect.bottom){
    pauseTimer();
    lpTimer = setTimeout(()=>{
      isLongPressOpeningLightbox = true;
      const card = playlist[session.index]; if(!card) return;
      const src = card.image.startsWith('http') ? card.image : (cfg.imageBase||'./') + card.image;
      el.mainLightboxImg.src = src;
      el.removeToggle.checked = false; // start unchecked
      el.mainLightbox.classList.add('show');
    }, LONG_PRESS_MS);
  }
}
function onTouchMove(e){
  const t=e.touches[0];
  lastTouchX = t.clientX; lastTouchY = t.clientY;
  if(!lpTimer) return;
  if(Math.abs(lastTouchX-touchStartX)>MOVE_TOL || Math.abs(lastTouchY-touchStartY)>MOVE_TOL){
    clearTimeout(lpTimer); lpTimer=null; resumeTimer();
  }
}
function onTouchEnd(e){
  if (el.settings.open || el.mainLightbox.classList.contains('show')) return;
  const duration = Date.now() - touchStartTime;
  const dx = Math.abs((lastTouchX||touchStartX) - touchStartX);
  const dy = Math.abs((lastTouchY||touchStartY) - touchStartY);
  if (lpTimer){ clearTimeout(lpTimer); lpTimer=null; resumeTimer(); }
  if (isLongPressOpeningLightbox){
    setTimeout(()=>{ isLongPressOpeningLightbox = false; }, 100);
    return;
  }
  if (duration < LONG_PRESS_MS && dx < MOVE_TOL && dy < MOVE_TOL){
    const rect = el.frame.getBoundingClientRect();
    const x = (e.changedTouches[0] ? e.changedTouches[0].clientX : touchStartX) - rect.left;
    lastTouchNavAt = Date.now();
    if (e.cancelable) e.preventDefault();
    if (x < rect.width/2){ stepBackward(); } else { revealNextStepOrCard(); }
  }
}

el.hits.addEventListener('click', onHitClick);
el.hits.addEventListener('touchstart', onTouchStart, {passive:false});
el.hits.addEventListener('touchmove',  onTouchMove,  {passive:false});
el.hits.addEventListener('touchend',   onTouchEnd,   {passive:false});
el.hits.addEventListener('touchcancel',onTouchEnd,   {passive:false});

/* Letterbox navigation */
function onStageClick(e){
  if (el.settings.open || el.mainLightbox.classList.contains('show')) return;
  if(e.target !== el.stage) return;
  const x = e.clientX;
  if(x < window.innerWidth/2){ stepBackward(); } else { revealNextStepOrCard(); }
}
el.stage.addEventListener('click', onStageClick);

el.artArea.addEventListener('contextmenu', (e) => e.preventDefault());

/* Lightbox close: apply removal if checked */
el.mainLightbox.addEventListener('click', (e) => {
  if(e.target === el.mainLightbox){
    const doRemove = el.removeToggle && el.removeToggle.checked;
    el.mainLightbox.classList.remove('show');
    if (doRemove) excludeCurrentAndMaybeReplace();
    resumeTimer();
  }
});
el.mainLightboxImg.addEventListener('contextmenu', (e) => {
  if(isLongPressOpeningLightbox){ e.preventDefault(); setTimeout(() => { isLongPressOpeningLightbox = false; }, 100); }
});

el.btnGood.addEventListener('click',()=>{ if(!playlist.length) return; grade(playlist[session.index],'good'); });
el.btnBad.addEventListener('click',()=>{ if(!playlist.length) return; grade(playlist[session.index],'bad'); });

el.btnSettings.addEventListener('click',()=>{ openSettings(); });
el.btnExport.addEventListener('click',exportData);
el.btnImport.addEventListener('click',importData);

/* Don't cancel dblclicks when interacting with form controls */
window.addEventListener('dblclick', e => {
  if (el.settings.open || e.target.closest('input, textarea, select, .modal, button')) return;
  e.preventDefault();
});

window.addEventListener('keydown',(e)=>{
  if(el.settings.open || el.mainLightbox.classList.contains('show')) return;
  if(e.key==='ArrowRight'){ revealNextStepOrCard(); }
  else if(e.key==='ArrowLeft'){ stepBackward(); }
  else if(e.key.toLowerCase()==='g'){ if(playlist.length) grade(playlist[session.index],'good'); }
  else if(e.key.toLowerCase()==='b'){ if(playlist.length) grade(playlist[session.index],'bad'); }
  else if(e.key.toLowerCase()==='s'){ openSettings(); }
});

/* exclude + maybe replace logic */
function excludeCurrentAndMaybeReplace(){
  const card = playlist[session.index]; if(!card) return;
  excluded.add(card.id); saveExcluded();

  const idxInToday = todaySel.ids.indexOf(card.id);
  if(idxInToday !== -1){ todaySel.ids.splice(idxInToday,1); saveToday(); }

  const p = ensureProgress(card);
  const wasNew = (p.state === 'new');

  if (wasNew){
    // find a replacement new card (not excluded and not already selected)
    const candidates = deck.filter(c =>
      !excluded.has(c.id) &&
      !todaySel.ids.includes(c.id) &&
      ensureProgress(c).state === 'new'
    );
    if (candidates.length){
      const repl = candidates[Math.floor(Math.random()*candidates.length)];
      if (idxInToday !== -1){ todaySel.ids.splice(idxInToday, 0, repl.id); }
      else { todaySel.ids.push(repl.id); }
      saveToday();
    }
  }

  // Rebuild playlist but keep the user at the same index position
  const targetIdx = Math.max(0, idxInToday !== -1 ? idxInToday : session.index);
  const map=new Map(deck.map(c=>[c.id,c]));
  const newPlaylist = todaySel.ids.map(id=>map.get(id)).filter(Boolean).filter(c=>!excluded.has(c.id));
  playlist = newPlaylist;
  session.index = Math.min(targetIdx, Math.max(0, playlist.length-1));
  showCurrent(true);
}

/* Boot */
async function init(){
  startClock();
  try{ const res=await fetch('deck.json'); deck=await res.json(); }catch(e){ deck=[]; }
  deck=deck.map(card=>({...card,id:String(card.id||card.title),artist:cleanText(card.artist),title:cleanText(card.title),date:cleanText(card.date),style:cleanText(card.style)}));
  if(!deck.length){ el.title.textContent='No deck.json found or empty.';return;}
  ensureToday(); buildPlaylist(); showCurrent(true);
  setupWakeLockOnce();
}
init();
</script>
</body>
</html>
